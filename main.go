package main

import (
	"flag"
	"fmt"

	temporalv1 "github.com/thomas-maurice/protoc-gen-go-tmprl/gen/temporal/v1"
	"github.com/thomas-maurice/protoc-gen-go-tmprl/internal/generator"
	"github.com/thomas-maurice/protoc-gen-go-tmprl/internal/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	genWorkflowPrefix bool
	// Default activity start to close timeout in seconds
	defaultActivityScheduleToClose int
)

func main() {
	var flags flag.FlagSet
	// This is to generate automatically prefixes for the jobs.
	flags.BoolVar(&genWorkflowPrefix, "gen-workflow-prefix", false, "Generates a prefix for the jobs like foo.v1.Foo.Method/<workflowID>")
	flags.IntVar(&defaultActivityScheduleToClose, "default-activity-schedule-to-close", 3600*24, "Default start to close activity timeout if none is specified anywhere, in seconds")
	opts := &protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(gen *protogen.Plugin) error {

		if defaultActivityScheduleToClose <= 0 {
			return fmt.Errorf("the default schedule to close activity timeout cannot be 0 nor negative")
		}

		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f, &generator.Config{
				GenWorkflowPrefix:              genWorkflowPrefix,
				DefaultActivityScheduleToClose: defaultActivityScheduleToClose,
			})
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File, config *generator.Config) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_tmprl.pb.go"

	needsGenerate := false
	for _, s := range file.Services {
		if so, ok := proto.GetExtension(s.Desc.Options(), temporalv1.E_Service).(*temporalv1.ServiceOptions); ok && so != nil {
			needsGenerate = true
		}
	}

	if !needsGenerate {
		return nil
	}

	gen := plugin.NewGeneratedFile(filename, file.GoImportPath)
	gen.P("// Code generated by protoc-gen-go-tmprl. DO NOT EDIT.")
	gen.P("//")
	gen.P("// version:")
	gen.P("//   protoc-gen-go-tmprl version: " + version.Version)
	gen.P("//   protoc-gen-go-tmprl commit: " + version.Commit)
	gen.P("//")
	gen.P("// source file: " + file.Proto.GetName())
	gen.P()
	gen.P("package ", file.GoPackageName)
	gen.P()

	for _, s := range file.Services {
		if so, ok := proto.GetExtension(s.Desc.Options(), temporalv1.E_Service).(*temporalv1.ServiceOptions); !ok || so == nil {
			// not a temporal service if the `temporal.v1.service` option is not set
			continue
		}

		err := generator.ServiceConstants(gen, s, config)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.UnimplementedServiceInterface(gen, s)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.Worker(gen, s)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.Client(gen, s, config)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.WorkflowObjects(gen, s)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.ServiceSignals(gen, s)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.ServiceQueries(gen, s)
		if err != nil {
			plugin.Error(err)
		}
	}

	return gen
}
