package main

import (
	"flag"
	"fmt"

	temporalv1 "github.com/thomas-maurice/protoc-gen-go-tmprl/gen/temporal/v1"
	"github.com/thomas-maurice/protoc-gen-go-tmprl/internal/generator"
	"github.com/thomas-maurice/protoc-gen-go-tmprl/internal/model"
	"github.com/thomas-maurice/protoc-gen-go-tmprl/internal/renderer"
	"github.com/thomas-maurice/protoc-gen-go-tmprl/internal/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	genWorkflowPrefix bool
	genDocs           bool
	// Default activity start to close timeout in seconds
	defaultActivityScheduleToClose int
)

func main() {
	var flags flag.FlagSet
	// This is to generate automatically prefixes for the jobs.
	flags.BoolVar(&genWorkflowPrefix, "gen-workflow-prefix", false, "Generates a prefix for the jobs like foo.v1.Foo.Method/<workflowID>")
	flags.IntVar(&defaultActivityScheduleToClose, "default-activity-schedule-to-close", 3600*24, "Default start to close activity timeout if none is specified anywhere, in seconds")
	flags.BoolVar(&genDocs, "gen-docs", false, "Generates documentation for the temporal workflows")
	opts := &protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(gen *protogen.Plugin) error {

		if defaultActivityScheduleToClose <= 0 {
			return fmt.Errorf("the default schedule to close activity timeout cannot be 0 nor negative")
		}

		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		config := &model.Config{
			GenWorkflowPrefix:              genWorkflowPrefix,
			DefaultActivityScheduleToClose: defaultActivityScheduleToClose,
		}

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			if err := generateFile(gen, f, config); err != nil {
				return err
			}

			if genDocs {
				if err := generateReadme(gen, f, config); err != nil {
					return err
				}
			}
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File, config *model.Config) error {
	filename := file.GeneratedFilenamePrefix + "_tmprl.pb.go"

	needsGenerate := false
	for _, s := range file.Services {
		if so, ok := proto.GetExtension(s.Desc.Options(), temporalv1.E_Service).(*temporalv1.ServiceOptions); ok && so != nil {
			needsGenerate = true
		}
	}

	if !needsGenerate {
		return nil
	}

	gen := plugin.NewGeneratedFile(filename, file.GoImportPath)
	gen.P("// Code generated by protoc-gen-go-tmprl. DO NOT EDIT.")
	gen.P("//")
	gen.P("// version:")
	gen.P("//   protoc-gen-go-tmprl version: " + version.Version)
	gen.P("//   protoc-gen-go-tmprl commit: " + version.Commit)
	gen.P("//")
	gen.P("// source file: " + file.Proto.GetName())
	gen.P()
	gen.P("package ", file.GoPackageName)
	gen.P()

	for _, s := range file.Services {
		if so, ok := proto.GetExtension(s.Desc.Options(), temporalv1.E_Service).(*temporalv1.ServiceOptions); !ok || so == nil {
			// not a temporal service if the `temporal.v1.service` option is not set
			continue
		}

		// Create service model
		service, err := model.NewService(s, gen, config)
		if err != nil {
			return fmt.Errorf("failed to create service model: %w", err)
		}

		// Create renderer
		r, err := renderer.NewRenderer(gen)
		if err != nil {
			return fmt.Errorf("failed to create renderer: %w", err)
		}

		// Render all components
		output, err := r.RenderAll(service)
		if err != nil {
			return fmt.Errorf("failed to render service %s: %w", service.GoName, err)
		}

		gen.P(output)
	}

	return nil
}

func generateReadme(plugin *protogen.Plugin, file *protogen.File, config *model.Config) error {
	filename := file.GeneratedFilenamePrefix + "_tmprl_doc.md"

	needsGenerate := false
	for _, s := range file.Services {
		if so, ok := proto.GetExtension(s.Desc.Options(), temporalv1.E_Service).(*temporalv1.ServiceOptions); ok && so != nil {
			needsGenerate = true
		}
	}

	if !needsGenerate {
		return nil
	}

	// Use old generator for now
	gen := plugin.NewGeneratedFile(filename, file.GoImportPath)
	gen.P(`<a id="top"></a>`)
	gen.P("# Services")

	// Convert to old config type for backward compatibility
	oldConfig := &generator.Config{
		GenWorkflowPrefix:              config.GenWorkflowPrefix,
		DefaultActivityScheduleToClose: config.DefaultActivityScheduleToClose,
	}

	for _, s := range file.Services {
		if so, ok := proto.GetExtension(s.Desc.Options(), temporalv1.E_Service).(*temporalv1.ServiceOptions); !ok || so == nil {
			// not a temporal service if the `temporal.v1.service` option is not set
			continue
		}

		err := generator.ReadmeService(gen, s, oldConfig)
		if err != nil {
			return err
		}
	}

	gen.P("# Messages")
	for _, m := range file.Messages {
		err := generator.ReadmeMessage(gen, m, oldConfig)
		if err != nil {
			return err
		}
	}

	gen.P("\n\n[Back to top](#top)")

	return nil
}
