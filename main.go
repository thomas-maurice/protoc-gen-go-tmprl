package main

import (
	"flag"

	temporalv1 "github.com/thomas-maurice/protoc-gen-go-tmprl/gen/v1"
	"github.com/thomas-maurice/protoc-gen-go-tmprl/internal/generator"
	"github.com/thomas-maurice/protoc-gen-go-tmprl/internal/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

var (
	flagParam *bool
)

func main() {
	var flags flag.FlagSet
	flagParam = flags.Bool("param", false, "")
	opts := &protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_tmprl.pb.go"
	gen := plugin.NewGeneratedFile(filename, file.GoImportPath)
	gen.P("// Code generated by protoc-gen-go-tmprl. DO NOT EDIT.")
	gen.P("// protoc-gen-go-tmprl version: " + version.Version)
	gen.P("// protoc-gen-go-tmprl commit: " + version.Commit)
	gen.P()
	gen.P("package ", file.GoPackageName)
	gen.P()

	for _, s := range file.Services {
		if _, ok := proto.GetExtension(s.Desc.Options(), temporalv1.E_Service).(*temporalv1.ServiceOptions); !ok {
			// not a temporal service if the `temporal.v1.service` option is not set
			continue
		}

		err := generator.ServiceConstants(gen, s)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.UnimplementedServiceInterface(gen, s)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.Worker(gen, s)
		if err != nil {
			plugin.Error(err)
		}

		err = generator.Client(gen, s)
		if err != nil {
			plugin.Error(err)
		}
	}

	return gen
}
