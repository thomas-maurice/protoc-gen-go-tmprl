// Code generated by protoc-gen-go-tmprl. DO NOT EDIT.
//
// version:
//   protoc-gen-go-tmprl version: master
//   protoc-gen-go-tmprl commit: master
//
// source file: example/v1/example.proto

package examplev1

import (
	context "context"
	fmt "fmt"
	uuid "github.com/google/uuid"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	time "time"
)

// Constants for DieRoll service
const (
	// DefaultDieRollTaskQueueName: Default task queue name for DieRoll
	DefaultDieRollTaskQueueName = "service-task-queue"

	// DefaultDieRollActivityScheduleToCloseTimeout: Default activity schedule to close timeout
	DefaultDieRollActivityScheduleToCloseTimeout = 86400

	// WorkflowParentWorkflowName: Registered name for workflow ParentWorkflow
	WorkflowParentWorkflowName = "example.v1.DieRoll.ParentWorkflow"

	// WorkflowChildWorkflowName: Registered name for workflow ChildWorkflow
	WorkflowChildWorkflowName = "example.v1.DieRoll.ChildWorkflow"

	// WorkflowThrowDiesName: Registered name for workflow ThrowDies
	WorkflowThrowDiesName = "example.v1.DieRoll.ThrowDies"

	// WorkflowThrowUntilValueName: Registered name for workflow ThrowUntilValue
	WorkflowThrowUntilValueName = "example.v1.DieRoll.ThrowUntilValue"

	// ActivityThrowDieName: Registered name for activity ThrowDie
	ActivityThrowDieName = "example.v1.DieRoll.ThrowDie"

	// ActivityPingName: Registered name for activity Ping
	ActivityPingName = "ping.Ping"

	// SignalContinueName: Registered name for signal Continue
	SignalContinueName = "example.v1.DieRoll.Continue"

	// QueryGetThrowsStatusName: Registered name for query GetThrowsStatus
	QueryGetThrowsStatusName = "example.v1.DieRoll.GetThrowsStatus"
)

// DieRollService: Interface that must be implemented to register workflows and activities
type DieRollService interface {
	// ParentWorkflow: Parent workflow that calls the Child workflow -- to test workflow ID generations mainly
	ParentWorkflow(ctx workflow.Context, req *emptypb.Empty) (*ParentWorkflowReply, error)
	// ChildWorkflow:
	ChildWorkflow(ctx workflow.Context, req *emptypb.Empty) (*emptypb.Empty, error)
	// ThrowDies: Throws dies a few times and return the result
	ThrowDies(ctx workflow.Context, req *ThrowDiesRequest) (*ThrowDiesResponse, error)
	// ThrowUntilValue:
	ThrowUntilValue(ctx workflow.Context, req *ThrowUntilValueRequest) (*emptypb.Empty, error)
	// ThrowDie: Throws a d6 and returns the result
	ThrowDie(ctx context.Context, req *emptypb.Empty) (*ThrowDieResponse, error)
	// Ping: Just a simple ping Takes no parameters returns nothing
	Ping(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error)
}

// UnimplementedDieRollService: Stub implementation that panics
type UnimplementedDieRollService struct{}

func (UnimplementedDieRollService) ParentWorkflow(ctx workflow.Context, req *emptypb.Empty) (*ParentWorkflowReply, error) {
	panic("ParentWorkflow not implemented")
}
func (UnimplementedDieRollService) ChildWorkflow(ctx workflow.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	panic("ChildWorkflow not implemented")
}
func (UnimplementedDieRollService) ThrowDies(ctx workflow.Context, req *ThrowDiesRequest) (*ThrowDiesResponse, error) {
	panic("ThrowDies not implemented")
}
func (UnimplementedDieRollService) ThrowUntilValue(ctx workflow.Context, req *ThrowUntilValueRequest) (*emptypb.Empty, error) {
	panic("ThrowUntilValue not implemented")
}
func (UnimplementedDieRollService) ThrowDie(ctx context.Context, req *emptypb.Empty) (*ThrowDieResponse, error) {
	panic("ThrowDie not implemented")
}
func (UnimplementedDieRollService) Ping(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	panic("Ping not implemented")
}

// DieRollClient: Client for the DieRoll service
type DieRollClient struct {
	client    client.Client
	taskQueue string
}

// NewDieRollClient: Returns a new instance of the client.
// If `taskQueue` stays empty the default one will be used
func NewDieRollClient(client client.Client, taskQueue ...string) (*DieRollClient, error) {
	clientTaskQueue := DefaultDieRollTaskQueueName
	if len(taskQueue) > 0 {
		clientTaskQueue = taskQueue[0]
	}

	return &DieRollClient{
		client:    client,
		taskQueue: clientTaskQueue,
	}, nil
}

// ExecuteWorkflowParentWorkflow: executes the workflow and returns a future to it
func (c *DieRollClient) ExecuteWorkflowParentWorkflow(ctx context.Context, req *emptypb.Empty, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.ID == "" {
		wOptions.ID = fmt.Sprintf("%s/%s", WorkflowParentWorkflowName, uuid.NewString())
	}

	// Apply timeout options
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(86400) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(7200) * time.Second
	}

	// Apply retry policy

	return c.client.ExecuteWorkflow(ctx, wOptions, WorkflowParentWorkflowName, req)
}

// ExecuteWorkflowParentWorkflowSync: executes the workflow and returns the result when finished
func (c *DieRollClient) ExecuteWorkflowParentWorkflowSync(ctx context.Context, req *emptypb.Empty, options ...client.StartWorkflowOptions) (*ParentWorkflowReply, error) {
	future, err := c.ExecuteWorkflowParentWorkflow(ctx, req, options...)
	if err != nil {
		return nil, err
	}

	var resp *ParentWorkflowReply
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// GetWorkflowParentWorkflowResult: gets the result of a given workflow
func (c *DieRollClient) GetWorkflowParentWorkflowResult(ctx context.Context, workflowId string, runId string) (*ParentWorkflowReply, error) {
	future := c.client.GetWorkflow(ctx, workflowId, runId)

	var resp *ParentWorkflowReply
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ExecuteChildParentWorkflow: executes the workflow as a child workflow and returns a future to it
func (c *DieRollClient) ExecuteChildParentWorkflow(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ChildWorkflowOptions) (workflow.ChildWorkflowFuture, error) {
	wOptions := workflow.ChildWorkflowOptions{}
	if len(options) > 0 {
		wOptions = options[0]
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = c.taskQueue
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.WorkflowID == "" {
		var id string
		genId := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {
			return fmt.Sprintf("%s/%s", WorkflowParentWorkflowName, uuid.NewString())
		})

		err := genId.Get(&id)
		if err != nil {
			return nil, err
		}

		wOptions.WorkflowID = id
	}

	// Apply timeout options
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(86400) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(7200) * time.Second
	}

	// Apply retry policy

	return workflow.ExecuteChildWorkflow(workflow.WithChildOptions(ctx, wOptions), WorkflowParentWorkflowName, req), nil
}

// ExecuteChildParentWorkflowSync: executes the workflow as a child workflow and returns the result when finished
func (c *DieRollClient) ExecuteChildParentWorkflowSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ChildWorkflowOptions) (*ParentWorkflowReply, error) {
	future, err := c.ExecuteChildParentWorkflow(ctx, req, options...)
	if err != nil {
		return nil, err
	}

	var resp *ParentWorkflowReply
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ExecuteWorkflowChildWorkflow: executes the workflow and returns a future to it
func (c *DieRollClient) ExecuteWorkflowChildWorkflow(ctx context.Context, req *emptypb.Empty, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.ID == "" {
		wOptions.ID = fmt.Sprintf("%s/%s", WorkflowChildWorkflowName, uuid.NewString())
	}

	// Apply timeout options
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(86400) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(7200) * time.Second
	}

	// Apply retry policy

	return c.client.ExecuteWorkflow(ctx, wOptions, WorkflowChildWorkflowName, req)
}

// ExecuteWorkflowChildWorkflowSync: executes the workflow and returns the result when finished
func (c *DieRollClient) ExecuteWorkflowChildWorkflowSync(ctx context.Context, req *emptypb.Empty, options ...client.StartWorkflowOptions) (*emptypb.Empty, error) {
	future, err := c.ExecuteWorkflowChildWorkflow(ctx, req, options...)
	if err != nil {
		return nil, err
	}

	var resp *emptypb.Empty
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// GetWorkflowChildWorkflowResult: gets the result of a given workflow
func (c *DieRollClient) GetWorkflowChildWorkflowResult(ctx context.Context, workflowId string, runId string) (*emptypb.Empty, error) {
	future := c.client.GetWorkflow(ctx, workflowId, runId)

	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ExecuteChildChildWorkflow: executes the workflow as a child workflow and returns a future to it
func (c *DieRollClient) ExecuteChildChildWorkflow(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ChildWorkflowOptions) (workflow.ChildWorkflowFuture, error) {
	wOptions := workflow.ChildWorkflowOptions{}
	if len(options) > 0 {
		wOptions = options[0]
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = c.taskQueue
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.WorkflowID == "" {
		var id string
		genId := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {
			return fmt.Sprintf("%s/%s", WorkflowChildWorkflowName, uuid.NewString())
		})

		err := genId.Get(&id)
		if err != nil {
			return nil, err
		}

		wOptions.WorkflowID = id
	}

	// Apply timeout options
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(86400) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(7200) * time.Second
	}

	// Apply retry policy

	return workflow.ExecuteChildWorkflow(workflow.WithChildOptions(ctx, wOptions), WorkflowChildWorkflowName, req), nil
}

// ExecuteChildChildWorkflowSync: executes the workflow as a child workflow and returns the result when finished
func (c *DieRollClient) ExecuteChildChildWorkflowSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ChildWorkflowOptions) (*emptypb.Empty, error) {
	future, err := c.ExecuteChildChildWorkflow(ctx, req, options...)
	if err != nil {
		return nil, err
	}

	var resp *emptypb.Empty
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ExecuteWorkflowThrowDies: executes the workflow and returns a future to it
func (c *DieRollClient) ExecuteWorkflowThrowDies(ctx context.Context, req *ThrowDiesRequest, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.ID == "" {
		wOptions.ID = fmt.Sprintf("%s/%s", WorkflowThrowDiesName, uuid.NewString())
	}

	// Apply timeout options
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(86400) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(7200) * time.Second
	}

	// Apply retry policy

	return c.client.ExecuteWorkflow(ctx, wOptions, WorkflowThrowDiesName, req)
}

// ExecuteWorkflowThrowDiesSync: executes the workflow and returns the result when finished
func (c *DieRollClient) ExecuteWorkflowThrowDiesSync(ctx context.Context, req *ThrowDiesRequest, options ...client.StartWorkflowOptions) (*ThrowDiesResponse, error) {
	future, err := c.ExecuteWorkflowThrowDies(ctx, req, options...)
	if err != nil {
		return nil, err
	}

	var resp *ThrowDiesResponse
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// GetWorkflowThrowDiesResult: gets the result of a given workflow
func (c *DieRollClient) GetWorkflowThrowDiesResult(ctx context.Context, workflowId string, runId string) (*ThrowDiesResponse, error) {
	future := c.client.GetWorkflow(ctx, workflowId, runId)

	var resp *ThrowDiesResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ExecuteChildThrowDies: executes the workflow as a child workflow and returns a future to it
func (c *DieRollClient) ExecuteChildThrowDies(ctx workflow.Context, req *ThrowDiesRequest, options ...workflow.ChildWorkflowOptions) (workflow.ChildWorkflowFuture, error) {
	wOptions := workflow.ChildWorkflowOptions{}
	if len(options) > 0 {
		wOptions = options[0]
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = c.taskQueue
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.WorkflowID == "" {
		var id string
		genId := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {
			return fmt.Sprintf("%s/%s", WorkflowThrowDiesName, uuid.NewString())
		})

		err := genId.Get(&id)
		if err != nil {
			return nil, err
		}

		wOptions.WorkflowID = id
	}

	// Apply timeout options
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(86400) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(7200) * time.Second
	}

	// Apply retry policy

	return workflow.ExecuteChildWorkflow(workflow.WithChildOptions(ctx, wOptions), WorkflowThrowDiesName, req), nil
}

// ExecuteChildThrowDiesSync: executes the workflow as a child workflow and returns the result when finished
func (c *DieRollClient) ExecuteChildThrowDiesSync(ctx workflow.Context, req *ThrowDiesRequest, options ...workflow.ChildWorkflowOptions) (*ThrowDiesResponse, error) {
	future, err := c.ExecuteChildThrowDies(ctx, req, options...)
	if err != nil {
		return nil, err
	}

	var resp *ThrowDiesResponse
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// CreateScheduleThrowDies: Creates a schedule for ThrowDies with the configured cron expression
func (c *DieRollClient) CreateScheduleThrowDies(ctx context.Context, scheduleID string, req *ThrowDiesRequest, options ...client.ScheduleOptions) (client.ScheduleHandle, error) {
	scheduleOptions := client.ScheduleOptions{
		ID: scheduleID,
		Spec: client.ScheduleSpec{
			CronExpressions: []string{"* * * * *"},
		},
		Action: &client.ScheduleWorkflowAction{
			ID:                       scheduleID,
			Workflow:                 WorkflowThrowDiesName,
			Args:                     []interface{}{req},
			TaskQueue:                c.taskQueue,
			WorkflowExecutionTimeout: time.Duration(86400) * time.Second,
			WorkflowRunTimeout:       time.Duration(7200) * time.Second,
		},
	}

	if len(options) > 0 {
		providedOptions := options[0]
		if providedOptions.ID != "" {
			scheduleOptions.ID = providedOptions.ID
		}
		if len(providedOptions.Spec.CronExpressions) > 0 {
			scheduleOptions.Spec.CronExpressions = providedOptions.Spec.CronExpressions
		}
		if providedOptions.Action != nil {
			scheduleOptions.Action = providedOptions.Action
		}
		if providedOptions.Paused {
			scheduleOptions.Paused = providedOptions.Paused
		}
		if providedOptions.Note != "" {
			scheduleOptions.Note = providedOptions.Note
		}
	}

	if scheduleOptions.Action.(*client.ScheduleWorkflowAction).TaskQueue == "" {
		scheduleOptions.Action.(*client.ScheduleWorkflowAction).TaskQueue = DefaultDieRollTaskQueueName
	}

	return c.client.ScheduleClient().Create(ctx, scheduleOptions)
}

// GetScheduleThrowDies: Gets a handle to an existing schedule for ThrowDies
func (c *DieRollClient) GetScheduleThrowDies(ctx context.Context, scheduleID string) client.ScheduleHandle {
	return c.client.ScheduleClient().GetHandle(ctx, scheduleID)
}

// ExecuteWorkflowThrowUntilValue: executes the workflow and returns a future to it
func (c *DieRollClient) ExecuteWorkflowThrowUntilValue(ctx context.Context, req *ThrowUntilValueRequest, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.ID == "" {
		wOptions.ID = fmt.Sprintf("%s/%s", WorkflowThrowUntilValueName, uuid.NewString())
	}

	// Apply timeout options
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(86400) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(7200) * time.Second
	}

	// Apply retry policy

	return c.client.ExecuteWorkflow(ctx, wOptions, WorkflowThrowUntilValueName, req)
}

// ExecuteWorkflowThrowUntilValueSync: executes the workflow and returns the result when finished
func (c *DieRollClient) ExecuteWorkflowThrowUntilValueSync(ctx context.Context, req *ThrowUntilValueRequest, options ...client.StartWorkflowOptions) (*emptypb.Empty, error) {
	future, err := c.ExecuteWorkflowThrowUntilValue(ctx, req, options...)
	if err != nil {
		return nil, err
	}

	var resp *emptypb.Empty
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// GetWorkflowThrowUntilValueResult: gets the result of a given workflow
func (c *DieRollClient) GetWorkflowThrowUntilValueResult(ctx context.Context, workflowId string, runId string) (*emptypb.Empty, error) {
	future := c.client.GetWorkflow(ctx, workflowId, runId)

	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ExecuteChildThrowUntilValue: executes the workflow as a child workflow and returns a future to it
func (c *DieRollClient) ExecuteChildThrowUntilValue(ctx workflow.Context, req *ThrowUntilValueRequest, options ...workflow.ChildWorkflowOptions) (workflow.ChildWorkflowFuture, error) {
	wOptions := workflow.ChildWorkflowOptions{}
	if len(options) > 0 {
		wOptions = options[0]
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = c.taskQueue
	}

	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.WorkflowID == "" {
		var id string
		genId := workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} {
			return fmt.Sprintf("%s/%s", WorkflowThrowUntilValueName, uuid.NewString())
		})

		err := genId.Get(&id)
		if err != nil {
			return nil, err
		}

		wOptions.WorkflowID = id
	}

	// Apply timeout options
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(86400) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(7200) * time.Second
	}

	// Apply retry policy

	return workflow.ExecuteChildWorkflow(workflow.WithChildOptions(ctx, wOptions), WorkflowThrowUntilValueName, req), nil
}

// ExecuteChildThrowUntilValueSync: executes the workflow as a child workflow and returns the result when finished
func (c *DieRollClient) ExecuteChildThrowUntilValueSync(ctx workflow.Context, req *ThrowUntilValueRequest, options ...workflow.ChildWorkflowOptions) (*emptypb.Empty, error) {
	future, err := c.ExecuteChildThrowUntilValue(ctx, req, options...)
	if err != nil {
		return nil, err
	}

	var resp *emptypb.Empty
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ExecuteActivityThrowDie: executes the activity asynchronously and returns a future to it
func (c *DieRollClient) ExecuteActivityThrowDie(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) workflow.Future {
	var aOptions workflow.ActivityOptions

	if len(options) > 0 {
		aOptions = options[0]
	}

	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = c.taskQueue
	}

	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = DefaultDieRollTaskQueueName
	}

	// Apply timeout options
	if aOptions.StartToCloseTimeout == 0 {
		aOptions.StartToCloseTimeout = time.Duration(120) * time.Second
	}
	if aOptions.ScheduleToCloseTimeout == 0 {
		aOptions.ScheduleToCloseTimeout = time.Duration(120) * time.Second
	}
	if aOptions.ScheduleToStartTimeout == 0 {
		aOptions.ScheduleToStartTimeout = time.Duration(30) * time.Second
	}

	// Apply retry policy
	if aOptions.RetryPolicy == nil {
		aOptions.RetryPolicy = &temporal.RetryPolicy{
			InitialInterval:    time.Duration(1) * time.Second,
			MaximumInterval:    time.Duration(10) * time.Second,
			BackoffCoefficient: 1.5,
			MaximumAttempts:    10,
			NonRetryableErrorTypes: []string{
				"FATAL",
				"NOT_FOUND",
			},
		}
	}

	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aOptions), ActivityThrowDieName, req)
}

// ExecuteActivityThrowDieSync: executes the activity synchronously and returns the result when finished
func (c *DieRollClient) ExecuteActivityThrowDieSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) (*ThrowDieResponse, error) {
	aOptions := workflow.ActivityOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		aOptions = options[0]
	}

	future := c.ExecuteActivityThrowDie(ctx, req, aOptions)

	var resp *ThrowDieResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ExecuteActivityPing: executes the activity asynchronously and returns a future to it
func (c *DieRollClient) ExecuteActivityPing(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) workflow.Future {
	var aOptions workflow.ActivityOptions

	if len(options) > 0 {
		aOptions = options[0]
	}

	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = c.taskQueue
	}

	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = DefaultDieRollTaskQueueName
	}

	// Apply timeout options
	if aOptions.ScheduleToCloseTimeout == 0 {
		aOptions.ScheduleToCloseTimeout = time.Duration(86400) * time.Second
	}
	if aOptions.HeartbeatTimeout == 0 {
		aOptions.HeartbeatTimeout = time.Duration(60) * time.Second
	}

	// Apply retry policy

	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aOptions), ActivityPingName, req)
}

// ExecuteActivityPingSync: executes the activity synchronously and returns the result when finished
func (c *DieRollClient) ExecuteActivityPingSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) (*emptypb.Empty, error) {
	aOptions := workflow.ActivityOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		aOptions = options[0]
	}

	future := c.ExecuteActivityPing(ctx, req, aOptions)

	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// DieRollWorker: Worker for the DieRoll service
type DieRollWorker struct {
	client client.Client
	worker worker.Worker
	svc    DieRollService
}

// NewDieRollWorker: Returns a new instance of the worker.
// If `taskQueue` stays empty the default one will be used
func NewDieRollWorker(client client.Client, svc DieRollService, taskQueue string, workerOptions ...worker.Options) (*DieRollWorker, error) {
	wOpts := worker.Options{}
	if taskQueue == "" {
		taskQueue = DefaultDieRollTaskQueueName
	}
	if len(workerOptions) > 0 {
		wOpts = workerOptions[0]
	}
	w := worker.New(client, taskQueue, wOpts)

	return &DieRollWorker{
		client: client,
		svc:    svc,
		worker: w,
	}, nil
}

// Register: registers the worker and its activities/workflows in temporal
func (w *DieRollWorker) Register() {
	// Registers activity ThrowDie
	w.worker.RegisterActivityWithOptions(w.svc.ThrowDie, activity.RegisterOptions{
		Name: ActivityThrowDieName,
	})
	// Registers activity Ping
	w.worker.RegisterActivityWithOptions(w.svc.Ping, activity.RegisterOptions{
		Name: ActivityPingName,
	})
	// Registers workflow ParentWorkflow
	w.worker.RegisterWorkflowWithOptions(w.svc.ParentWorkflow, workflow.RegisterOptions{
		Name: WorkflowParentWorkflowName,
	})
	// Registers workflow ChildWorkflow
	w.worker.RegisterWorkflowWithOptions(w.svc.ChildWorkflow, workflow.RegisterOptions{
		Name: WorkflowChildWorkflowName,
	})
	// Registers workflow ThrowDies
	w.worker.RegisterWorkflowWithOptions(w.svc.ThrowDies, workflow.RegisterOptions{
		Name: WorkflowThrowDiesName,
	})
	// Registers workflow ThrowUntilValue
	w.worker.RegisterWorkflowWithOptions(w.svc.ThrowUntilValue, workflow.RegisterOptions{
		Name: WorkflowThrowUntilValueName,
	})
}

// Start: will run the worker in a non-blocking fashion. Use Stop() to stop the worker.
func (w *DieRollWorker) Start() error {
	return w.worker.Start()
}

// Run: will run the worker until interruptCh receives a signal. Use worker.InterruptCh() to interrupt when there's an interrupt signal from the OS.
func (w *DieRollWorker) Run(interruptCh <-chan any) error {
	return w.worker.Run(interruptCh)
}

// Stop: will stop the worker, may panic if called twice
func (w *DieRollWorker) Stop() {
	w.worker.Stop()
}

// DieRollParentWorkflow: is a struct that wraps a workflow
type DieRollParentWorkflow struct {
	client     client.Client
	future     client.WorkflowRun
	workflowId string
	runId      string
}

// GetParentWorkflow: gets an instance of a given workflow
func (c *DieRollClient) GetParentWorkflow(ctx context.Context, workflowId string, runId string) *DieRollParentWorkflow {
	future := c.client.GetWorkflow(ctx, workflowId, runId)

	return &DieRollParentWorkflow{
		client:     c.client,
		future:     future,
		workflowId: workflowId,
		runId:      runId,
	}
}

// GetParentWorkflowFromRun: gets an instance of a given workflow from a future
func (c *DieRollClient) GetParentWorkflowFromRun(future client.WorkflowRun) *DieRollParentWorkflow {
	return &DieRollParentWorkflow{
		workflowId: future.GetID(),
		runId:      future.GetRunID(),
		client:     c.client,
		future:     future,
	}
}

// Cancel: cancels a given workflow
func (w *DieRollParentWorkflow) Cancel(ctx context.Context) error {
	return w.client.CancelWorkflow(ctx, w.workflowId, w.runId)
}

// GetID: Returns the workflow ID
func (w *DieRollParentWorkflow) GetID() string {
	return w.future.GetID()
}

// GetRunID: Returns the run ID
func (w *DieRollParentWorkflow) GetRunID() string {
	return w.future.GetRunID()
}

// Terminate: terminates a given workflow
func (w *DieRollParentWorkflow) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return w.client.TerminateWorkflow(ctx, w.workflowId, w.runId, reason, details...)
}

// Result: gets the result of a given workflow with its native type
func (w *DieRollParentWorkflow) Result(ctx context.Context) (*ParentWorkflowReply, error) {
	var resp *ParentWorkflowReply

	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ResultWithOptions: gets the result of a given workflow with its native type
func (w *DieRollParentWorkflow) ResultWithOptions(ctx context.Context, options client.WorkflowRunGetOptions) (*ParentWorkflowReply, error) {
	var resp *ParentWorkflowReply

	err := w.future.GetWithOptions(ctx, &resp, options)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// Get: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollParentWorkflow) Get(ctx context.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// GetWithOptions: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollParentWorkflow) GetWithOptions(ctx context.Context, valuePtr interface{}, options client.WorkflowRunGetOptions) error {
	return w.future.GetWithOptions(ctx, valuePtr, options)
}

// SignalContinue: sends the Continue signal to the workflow
func (w *DieRollParentWorkflow) SignalContinue(ctx context.Context, req *ContinueSignalRequest) error {
	return w.client.SignalWorkflow(ctx, w.future.GetID(), w.future.GetRunID(), SignalContinueName, req)
}

// ChildDieRollParentWorkflowExecution: is a struct that wraps a workflow execution (called from another workflow)
type ChildDieRollParentWorkflowExecution struct {
	client client.Client
	future workflow.ChildWorkflowFuture
}

// GetChildDieRollParentWorkflowExecution: gets an instance of a given workflow from a future
func (c *DieRollClient) GetChildDieRollParentWorkflowExecution(future workflow.ChildWorkflowFuture) *ChildDieRollParentWorkflowExecution {
	return &ChildDieRollParentWorkflowExecution{
		client: c.client,
		future: future,
	}
}

// Result: gets the result of a given workflow with its native type
func (w *ChildDieRollParentWorkflowExecution) Result(ctx workflow.Context) (*ParentWorkflowReply, error) {
	var resp *ParentWorkflowReply

	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// Get: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollParentWorkflowExecution) Get(ctx workflow.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// GetChildWorkflowExecution: Wraps the GetChildWorkflowExecution and returns an workflow.Future
func (w *ChildDieRollParentWorkflowExecution) GetChildWorkflowExecution() workflow.Future {
	return w.future
}

// IsReady: Wraps the IsReady method from the future
func (w *ChildDieRollParentWorkflowExecution) IsReady() bool {
	return w.future.IsReady()
}

// SignalChildWorkflow: Signals the child workflow with a generic signal -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollParentWorkflowExecution) SignalChildWorkflow(ctx workflow.Context, sigName string, data interface{}) workflow.Future {
	return w.future.SignalChildWorkflow(ctx, sigName, data)
}

// SignalContinue: sends the Continue signal to the workflow
func (w *ChildDieRollParentWorkflowExecution) SignalContinue(ctx workflow.Context, req *ContinueSignalRequest) error {
	return w.future.SignalChildWorkflow(ctx, SignalContinueName, req).Get(ctx, nil)
}

// DieRollChildWorkflow: is a struct that wraps a workflow
type DieRollChildWorkflow struct {
	client     client.Client
	future     client.WorkflowRun
	workflowId string
	runId      string
}

// GetChildWorkflow: gets an instance of a given workflow
func (c *DieRollClient) GetChildWorkflow(ctx context.Context, workflowId string, runId string) *DieRollChildWorkflow {
	future := c.client.GetWorkflow(ctx, workflowId, runId)

	return &DieRollChildWorkflow{
		client:     c.client,
		future:     future,
		workflowId: workflowId,
		runId:      runId,
	}
}

// GetChildWorkflowFromRun: gets an instance of a given workflow from a future
func (c *DieRollClient) GetChildWorkflowFromRun(future client.WorkflowRun) *DieRollChildWorkflow {
	return &DieRollChildWorkflow{
		workflowId: future.GetID(),
		runId:      future.GetRunID(),
		client:     c.client,
		future:     future,
	}
}

// Cancel: cancels a given workflow
func (w *DieRollChildWorkflow) Cancel(ctx context.Context) error {
	return w.client.CancelWorkflow(ctx, w.workflowId, w.runId)
}

// GetID: Returns the workflow ID
func (w *DieRollChildWorkflow) GetID() string {
	return w.future.GetID()
}

// GetRunID: Returns the run ID
func (w *DieRollChildWorkflow) GetRunID() string {
	return w.future.GetRunID()
}

// Terminate: terminates a given workflow
func (w *DieRollChildWorkflow) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return w.client.TerminateWorkflow(ctx, w.workflowId, w.runId, reason, details...)
}

// Result: gets the result of a given workflow with its native type
func (w *DieRollChildWorkflow) Result(ctx context.Context) (*emptypb.Empty, error) {
	var resp *emptypb.Empty

	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ResultWithOptions: gets the result of a given workflow with its native type
func (w *DieRollChildWorkflow) ResultWithOptions(ctx context.Context, options client.WorkflowRunGetOptions) (*emptypb.Empty, error) {
	var resp *emptypb.Empty

	err := w.future.GetWithOptions(ctx, &resp, options)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// Get: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollChildWorkflow) Get(ctx context.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// GetWithOptions: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollChildWorkflow) GetWithOptions(ctx context.Context, valuePtr interface{}, options client.WorkflowRunGetOptions) error {
	return w.future.GetWithOptions(ctx, valuePtr, options)
}

// ChildDieRollChildWorkflowExecution: is a struct that wraps a workflow execution (called from another workflow)
type ChildDieRollChildWorkflowExecution struct {
	client client.Client
	future workflow.ChildWorkflowFuture
}

// GetChildDieRollChildWorkflowExecution: gets an instance of a given workflow from a future
func (c *DieRollClient) GetChildDieRollChildWorkflowExecution(future workflow.ChildWorkflowFuture) *ChildDieRollChildWorkflowExecution {
	return &ChildDieRollChildWorkflowExecution{
		client: c.client,
		future: future,
	}
}

// Result: gets the result of a given workflow with its native type
func (w *ChildDieRollChildWorkflowExecution) Result(ctx workflow.Context) (*emptypb.Empty, error) {
	var resp *emptypb.Empty

	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// Get: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollChildWorkflowExecution) Get(ctx workflow.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// GetChildWorkflowExecution: Wraps the GetChildWorkflowExecution and returns an workflow.Future
func (w *ChildDieRollChildWorkflowExecution) GetChildWorkflowExecution() workflow.Future {
	return w.future
}

// IsReady: Wraps the IsReady method from the future
func (w *ChildDieRollChildWorkflowExecution) IsReady() bool {
	return w.future.IsReady()
}

// SignalChildWorkflow: Signals the child workflow with a generic signal -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollChildWorkflowExecution) SignalChildWorkflow(ctx workflow.Context, sigName string, data interface{}) workflow.Future {
	return w.future.SignalChildWorkflow(ctx, sigName, data)
}

// DieRollThrowDies: is a struct that wraps a workflow
type DieRollThrowDies struct {
	client     client.Client
	future     client.WorkflowRun
	workflowId string
	runId      string
}

// GetThrowDies: gets an instance of a given workflow
func (c *DieRollClient) GetThrowDies(ctx context.Context, workflowId string, runId string) *DieRollThrowDies {
	future := c.client.GetWorkflow(ctx, workflowId, runId)

	return &DieRollThrowDies{
		client:     c.client,
		future:     future,
		workflowId: workflowId,
		runId:      runId,
	}
}

// GetThrowDiesFromRun: gets an instance of a given workflow from a future
func (c *DieRollClient) GetThrowDiesFromRun(future client.WorkflowRun) *DieRollThrowDies {
	return &DieRollThrowDies{
		workflowId: future.GetID(),
		runId:      future.GetRunID(),
		client:     c.client,
		future:     future,
	}
}

// Cancel: cancels a given workflow
func (w *DieRollThrowDies) Cancel(ctx context.Context) error {
	return w.client.CancelWorkflow(ctx, w.workflowId, w.runId)
}

// GetID: Returns the workflow ID
func (w *DieRollThrowDies) GetID() string {
	return w.future.GetID()
}

// GetRunID: Returns the run ID
func (w *DieRollThrowDies) GetRunID() string {
	return w.future.GetRunID()
}

// Terminate: terminates a given workflow
func (w *DieRollThrowDies) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return w.client.TerminateWorkflow(ctx, w.workflowId, w.runId, reason, details...)
}

// Result: gets the result of a given workflow with its native type
func (w *DieRollThrowDies) Result(ctx context.Context) (*ThrowDiesResponse, error) {
	var resp *ThrowDiesResponse

	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ResultWithOptions: gets the result of a given workflow with its native type
func (w *DieRollThrowDies) ResultWithOptions(ctx context.Context, options client.WorkflowRunGetOptions) (*ThrowDiesResponse, error) {
	var resp *ThrowDiesResponse

	err := w.future.GetWithOptions(ctx, &resp, options)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// Get: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollThrowDies) Get(ctx context.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// GetWithOptions: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollThrowDies) GetWithOptions(ctx context.Context, valuePtr interface{}, options client.WorkflowRunGetOptions) error {
	return w.future.GetWithOptions(ctx, valuePtr, options)
}

// SignalContinue: sends the Continue signal to the workflow
func (w *DieRollThrowDies) SignalContinue(ctx context.Context, req *ContinueSignalRequest) error {
	return w.client.SignalWorkflow(ctx, w.future.GetID(), w.future.GetRunID(), SignalContinueName, req)
}

// ChildDieRollThrowDiesExecution: is a struct that wraps a workflow execution (called from another workflow)
type ChildDieRollThrowDiesExecution struct {
	client client.Client
	future workflow.ChildWorkflowFuture
}

// GetChildDieRollThrowDiesExecution: gets an instance of a given workflow from a future
func (c *DieRollClient) GetChildDieRollThrowDiesExecution(future workflow.ChildWorkflowFuture) *ChildDieRollThrowDiesExecution {
	return &ChildDieRollThrowDiesExecution{
		client: c.client,
		future: future,
	}
}

// Result: gets the result of a given workflow with its native type
func (w *ChildDieRollThrowDiesExecution) Result(ctx workflow.Context) (*ThrowDiesResponse, error) {
	var resp *ThrowDiesResponse

	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// Get: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollThrowDiesExecution) Get(ctx workflow.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// GetChildWorkflowExecution: Wraps the GetChildWorkflowExecution and returns an workflow.Future
func (w *ChildDieRollThrowDiesExecution) GetChildWorkflowExecution() workflow.Future {
	return w.future
}

// IsReady: Wraps the IsReady method from the future
func (w *ChildDieRollThrowDiesExecution) IsReady() bool {
	return w.future.IsReady()
}

// SignalChildWorkflow: Signals the child workflow with a generic signal -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollThrowDiesExecution) SignalChildWorkflow(ctx workflow.Context, sigName string, data interface{}) workflow.Future {
	return w.future.SignalChildWorkflow(ctx, sigName, data)
}

// SignalContinue: sends the Continue signal to the workflow
func (w *ChildDieRollThrowDiesExecution) SignalContinue(ctx workflow.Context, req *ContinueSignalRequest) error {
	return w.future.SignalChildWorkflow(ctx, SignalContinueName, req).Get(ctx, nil)
}

// DieRollThrowUntilValue: is a struct that wraps a workflow
type DieRollThrowUntilValue struct {
	client     client.Client
	future     client.WorkflowRun
	workflowId string
	runId      string
}

// GetThrowUntilValue: gets an instance of a given workflow
func (c *DieRollClient) GetThrowUntilValue(ctx context.Context, workflowId string, runId string) *DieRollThrowUntilValue {
	future := c.client.GetWorkflow(ctx, workflowId, runId)

	return &DieRollThrowUntilValue{
		client:     c.client,
		future:     future,
		workflowId: workflowId,
		runId:      runId,
	}
}

// GetThrowUntilValueFromRun: gets an instance of a given workflow from a future
func (c *DieRollClient) GetThrowUntilValueFromRun(future client.WorkflowRun) *DieRollThrowUntilValue {
	return &DieRollThrowUntilValue{
		workflowId: future.GetID(),
		runId:      future.GetRunID(),
		client:     c.client,
		future:     future,
	}
}

// Cancel: cancels a given workflow
func (w *DieRollThrowUntilValue) Cancel(ctx context.Context) error {
	return w.client.CancelWorkflow(ctx, w.workflowId, w.runId)
}

// GetID: Returns the workflow ID
func (w *DieRollThrowUntilValue) GetID() string {
	return w.future.GetID()
}

// GetRunID: Returns the run ID
func (w *DieRollThrowUntilValue) GetRunID() string {
	return w.future.GetRunID()
}

// Terminate: terminates a given workflow
func (w *DieRollThrowUntilValue) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return w.client.TerminateWorkflow(ctx, w.workflowId, w.runId, reason, details...)
}

// Result: gets the result of a given workflow with its native type
func (w *DieRollThrowUntilValue) Result(ctx context.Context) (*emptypb.Empty, error) {
	var resp *emptypb.Empty

	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ResultWithOptions: gets the result of a given workflow with its native type
func (w *DieRollThrowUntilValue) ResultWithOptions(ctx context.Context, options client.WorkflowRunGetOptions) (*emptypb.Empty, error) {
	var resp *emptypb.Empty

	err := w.future.GetWithOptions(ctx, &resp, options)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// Get: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollThrowUntilValue) Get(ctx context.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// GetWithOptions: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollThrowUntilValue) GetWithOptions(ctx context.Context, valuePtr interface{}, options client.WorkflowRunGetOptions) error {
	return w.future.GetWithOptions(ctx, valuePtr, options)
}

// QueryGetThrowsStatus: queries the workflow with GetThrowsStatus
func (w *DieRollThrowUntilValue) QueryGetThrowsStatus(ctx context.Context, req *emptypb.Empty) (*ThrowStatusResponse, error) {
	future, err := w.client.QueryWorkflow(ctx, w.future.GetID(), w.future.GetRunID(), QueryGetThrowsStatusName, req)
	if err != nil {
		return nil, err
	}

	var resp *ThrowStatusResponse
	err = future.Get(&resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ChildDieRollThrowUntilValueExecution: is a struct that wraps a workflow execution (called from another workflow)
type ChildDieRollThrowUntilValueExecution struct {
	client client.Client
	future workflow.ChildWorkflowFuture
}

// GetChildDieRollThrowUntilValueExecution: gets an instance of a given workflow from a future
func (c *DieRollClient) GetChildDieRollThrowUntilValueExecution(future workflow.ChildWorkflowFuture) *ChildDieRollThrowUntilValueExecution {
	return &ChildDieRollThrowUntilValueExecution{
		client: c.client,
		future: future,
	}
}

// Result: gets the result of a given workflow with its native type
func (w *ChildDieRollThrowUntilValueExecution) Result(ctx workflow.Context) (*emptypb.Empty, error) {
	var resp *emptypb.Empty

	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// Get: gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollThrowUntilValueExecution) Get(ctx workflow.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// GetChildWorkflowExecution: Wraps the GetChildWorkflowExecution and returns an workflow.Future
func (w *ChildDieRollThrowUntilValueExecution) GetChildWorkflowExecution() workflow.Future {
	return w.future
}

// IsReady: Wraps the IsReady method from the future
func (w *ChildDieRollThrowUntilValueExecution) IsReady() bool {
	return w.future.IsReady()
}

// SignalChildWorkflow: Signals the child workflow with a generic signal -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollThrowUntilValueExecution) SignalChildWorkflow(ctx workflow.Context, sigName string, data interface{}) workflow.Future {
	return w.future.SignalChildWorkflow(ctx, sigName, data)
}

// SendSignalContinue: sends the Continue signal to a workflow
func (c *DieRollClient) SendSignalContinue(ctx context.Context, workflowID string, runID string, req *ContinueSignalRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SignalContinueName, req)
}

// ReceiveSignalContinue: waits for the the Continue signal
func ReceiveSignalContinue(ctx workflow.Context) (*ContinueSignalRequest, bool) {
	var result *ContinueSignalRequest
	ok := workflow.GetSignalChannel(ctx, SignalContinueName).Receive(ctx, &result)
	return result, ok
}

// ReceiveSignalContinueAsync: recieves the the Continue signal asynchronously. It doesn't wait if there is no signal in the queue
func ReceiveSignalContinueAsync(ctx workflow.Context) (*ContinueSignalRequest, bool) {
	var result *ContinueSignalRequest
	ok := workflow.GetSignalChannel(ctx, SignalContinueName).ReceiveAsync(&result)
	return result, ok
}

// QueryGetThrowsStatus: sends the GetThrowsStatus query to a workflow
func (c *DieRollClient) QueryGetThrowsStatus(ctx context.Context, workflowID string, runID string, req *emptypb.Empty) (*ThrowStatusResponse, error) {
	future, err := c.client.QueryWorkflow(ctx, workflowID, runID, QueryGetThrowsStatusName, req)
	if err != nil {
		return nil, err
	}

	var resp *ThrowStatusResponse
	err = future.Get(&resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// HandleQueryGetThrowsStatus: sets up the GetThrowsStatus query and responds accordingly, returns an error if it failed
func HandleQueryGetThrowsStatus(ctx workflow.Context, queryFunc func(req *emptypb.Empty) (*ThrowStatusResponse, error)) error {
	return workflow.SetQueryHandler(ctx, QueryGetThrowsStatusName, func(req *emptypb.Empty) (*ThrowStatusResponse, error) {
		return queryFunc(req)
	})
}
