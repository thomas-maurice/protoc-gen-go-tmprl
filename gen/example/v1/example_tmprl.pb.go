// Code generated by protoc-gen-go-tmprl. DO NOT EDIT.
//
// version:
//   protoc-gen-go-tmprl version: master
//   protoc-gen-go-tmprl commit: master
// source file: example/v1/example.proto

package examplev1

import (
	context "context"
	fmt "fmt"
	uuid "github.com/google/uuid"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	time "time"
)

const ( // Default task queue name for the service
	DefaultHelloWorldTaskQueueName = "hello-task-queue"

	// Workflows names constants

	// Name of workflow example.v1.HelloWorld.SayMultipleHello
	WorkflowHelloWorldSayMultipleHelloName = "example.v1.HelloWorld.SayMultipleHello"
	// Name of workflow example.v1.HelloWorld.SomeOtherWorkflow
	WorkflowHelloWorldSomeOtherWorkflowName = "example.v1.HelloWorld.SomeOtherWorkflow"

	// Activities names constants

	// Name of activity example.v1.HelloWorld.SayHello
	ActivityHelloWorldSayHelloName = "example.v1.HelloWorld.SayHello"
	// Name of activity example.v1.HelloWorld.Ping
	ActivityHelloWorldPingName = "ping.Ping"

	// Signals names constants

	// Name of signal example.v1.HelloWorld.Continue
	SignalHelloWorldContinueName = "example.v1.HelloWorld.Continue"

	// Queries names constants

	// Name of query example.v1.HelloWorld.GetStatus
	QueryHelloWorldGetStatusName = "example.v1.HelloWorld.GetStatus"

	// Default timeout for activities when none is specified
	DefaultHelloWorldScheduleToCloseTimeout = time.Hour
	// Default timeout for activities when none is specified
	DefaultHelloWorldStartToCloseTimeout = time.Hour
)

// HelloWorldService is the interface your service must implement
//
// Service hello world is an example implementation of a service

type HelloWorldService interface {
	// Workflows definitions

	// Say hello to multiple people
	SayMultipleHello(ctx workflow.Context, req *MultipleHelloRequest) (*MultipleHelloResponse, error)
	// Some other workflow we can call and does nothing
	SomeOtherWorkflow(ctx workflow.Context, req *emptypb.Empty) (*emptypb.Empty, error)

	// Activities definitions

	// Says hello and returns a string
	SayHello(ctx context.Context, req *HelloRequest) (*HelloResponse, error)
	// Just a simple ping
	// Takes no parameters
	// returns nothing
	Ping(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error)
}

// HelloWorldWorker: Worker for the HelloWorld service
type HelloWorldWorker struct {
	client client.Client
	worker worker.Worker
	svc    HelloWorldService
}

// NewHelloWorldWorker: Returns a new instance of the worker.
// If `taskQueue` stays empty the default one will be used
func NewHelloWorldWorker(client client.Client, svc HelloWorldService, taskQueue string, workerOptions ...worker.Options) (*HelloWorldWorker, error) {
	wOpts := worker.Options{}
	if taskQueue == "" {
		taskQueue = DefaultHelloWorldTaskQueueName
	}
	if len(workerOptions) > 0 {
		wOpts = workerOptions[0]
	}
	w := worker.New(client, taskQueue, wOpts)
	return &HelloWorldWorker{
		client: client,
		svc:    svc,
		worker: w,
	}, nil
}

// Register registers the worker and its activities/workflows in temporal
func (w *HelloWorldWorker) Register() {
	// Registers activity SayHello
	w.worker.RegisterActivityWithOptions(w.svc.SayHello, activity.RegisterOptions{
		Name: "example.v1.HelloWorld.SayHello",
	})
	// Registers activity Ping
	w.worker.RegisterActivityWithOptions(w.svc.Ping, activity.RegisterOptions{
		Name: "ping.Ping",
	})
	// Registers workflow SayMultipleHello
	w.worker.RegisterWorkflowWithOptions(w.svc.SayMultipleHello, workflow.RegisterOptions{
		Name: "example.v1.HelloWorld.SayMultipleHello",
	})
	// Registers workflow SomeOtherWorkflow
	w.worker.RegisterWorkflowWithOptions(w.svc.SomeOtherWorkflow, workflow.RegisterOptions{
		Name: "example.v1.HelloWorld.SomeOtherWorkflow",
	})
}

// Run will run the worker
func (w *HelloWorldWorker) Run() error {
	return w.worker.Run(worker.InterruptCh())
}

// Stop will stop the worker, may panic if called twice
func (w *HelloWorldWorker) Stop() {
	w.worker.Stop()
}

// HelloWorldClient: Client for the HelloWorld service
type HelloWorldClient struct {
	client    client.Client
	taskQueue string
}

// NewHelloWorldClient: Returns a new instance of the client.
// If `taskQueue` stays empty the default one will be used
func NewHelloWorldClient(client client.Client, taskQueue ...string) (*HelloWorldClient, error) {
	clientTaskQueue := DefaultHelloWorldTaskQueueName
	if len(taskQueue) > 0 {
		clientTaskQueue = taskQueue[0]
	}
	return &HelloWorldClient{
		client:    client,
		taskQueue: clientTaskQueue,
	}, nil
}

// ExecuteActivitySayHello executes the activity asynchronously and returns a future to it
func (c *HelloWorldClient) ExecuteActivitySayHello(ctx workflow.Context, req *HelloRequest, options ...workflow.ActivityOptions) workflow.Future {
	var aOptions workflow.ActivityOptions
	if len(options) > 0 {
		aOptions = options[0]
	}
	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	if aOptions.ActivityID == "" {
		aOptions.ActivityID = fmt.Sprintf("%s/%s", "example.v1.HelloWorld.SayHello", uuid.NewString())
	}
	if aOptions.ScheduleToCloseTimeout == 0 {
		aOptions.ScheduleToCloseTimeout = DefaultHelloWorldScheduleToCloseTimeout
	}
	if aOptions.StartToCloseTimeout == 0 {
		aOptions.StartToCloseTimeout = DefaultHelloWorldStartToCloseTimeout
	}
	if aOptions.StartToCloseTimeout == 0 {
		aOptions.StartToCloseTimeout = time.Duration(int32(120)) * time.Second
	}
	if aOptions.ScheduleToCloseTimeout == 0 {
		aOptions.ScheduleToCloseTimeout = time.Duration(int32(120)) * time.Second
	}
	if aOptions.ScheduleToStartTimeout == 0 {
		aOptions.ScheduleToStartTimeout = time.Duration(int32(30)) * time.Second
	}
	if aOptions.RetryPolicy == nil {
		aOptions.RetryPolicy = &temporal.RetryPolicy{
			InitialInterval:    time.Duration(int32(1)) * time.Second,
			MaximumInterval:    time.Duration(int32(10)) * time.Second,
			BackoffCoefficient: float64(float32(1.5)),
			MaximumAttempts:    int32(10),
			NonRetryableErrorTypes: []string{
				"FATAL",
			},
		}
	}
	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aOptions), "example.v1.HelloWorld.SayHello", req)
}

// ExecuteActivitySayHelloSync executes the activity synchronously and returns the result when finished
func (c *HelloWorldClient) ExecuteActivitySayHelloSync(ctx workflow.Context, req *HelloRequest, options ...workflow.ActivityOptions) (*HelloResponse, error) {
	aOptions := workflow.ActivityOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		aOptions = options[0]
	}
	future := c.ExecuteActivitySayHello(ctx, req, aOptions)
	var resp *HelloResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteActivityPing executes the activity asynchronously and returns a future to it
func (c *HelloWorldClient) ExecuteActivityPing(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) workflow.Future {
	var aOptions workflow.ActivityOptions
	if len(options) > 0 {
		aOptions = options[0]
	}
	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	if aOptions.ActivityID == "" {
		aOptions.ActivityID = fmt.Sprintf("%s/%s", "ping.Ping", uuid.NewString())
	}
	if aOptions.ScheduleToCloseTimeout == 0 {
		aOptions.ScheduleToCloseTimeout = DefaultHelloWorldScheduleToCloseTimeout
	}
	if aOptions.StartToCloseTimeout == 0 {
		aOptions.StartToCloseTimeout = DefaultHelloWorldStartToCloseTimeout
	}
	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aOptions), "ping.Ping", req)
}

// ExecuteActivityPingSync executes the activity synchronously and returns the result when finished
func (c *HelloWorldClient) ExecuteActivityPingSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) (*emptypb.Empty, error) {
	aOptions := workflow.ActivityOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		aOptions = options[0]
	}
	future := c.ExecuteActivityPing(ctx, req, aOptions)
	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteWorkflowSayMultipleHello executes the workflow and returns a future to it
func (c *HelloWorldClient) ExecuteWorkflowSayMultipleHello(ctx context.Context, req *MultipleHelloRequest, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	if wOptions.ID == "" {
		wOptions.ID = fmt.Sprintf("%s/%s", "example.v1.HelloWorld.SayMultipleHello", uuid.NewString())
	}
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(int32(86400)) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(int32(7200)) * time.Second
	}
	return c.client.ExecuteWorkflow(ctx, wOptions, "example.v1.HelloWorld.SayMultipleHello", req)
}

// ExecuteWorkflowSayMultipleHelloSync executes the workflow and returns the result when finished
func (c *HelloWorldClient) ExecuteWorkflowSayMultipleHelloSync(ctx context.Context, req *MultipleHelloRequest, options ...client.StartWorkflowOptions) (*MultipleHelloResponse, error) {
	future, err := c.ExecuteWorkflowSayMultipleHello(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	var resp *MultipleHelloResponse
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// GetWorkflowSayMultipleHelloResult gets the result of a given workflow
func (c *HelloWorldClient) GetWorkflowSayMultipleHelloResult(ctx context.Context, workflowId string, runId string) (*MultipleHelloResponse, error) {
	future := c.client.GetWorkflow(ctx, workflowId, runId)
	var resp *MultipleHelloResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteChildSayMultipleHello executes the workflow as a child workflow and returns a future to it
func (c *HelloWorldClient) ExecuteChildSayMultipleHello(ctx workflow.Context, req *MultipleHelloRequest, options ...workflow.ChildWorkflowOptions) workflow.ChildWorkflowFuture {
	wOptions := workflow.ChildWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	if wOptions.WorkflowID == "" {
		wOptions.WorkflowID = fmt.Sprintf("%s/%s", "example.v1.HelloWorld.SayMultipleHello", uuid.NewString())
	}
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(int32(86400)) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(int32(7200)) * time.Second
	}
	return workflow.ExecuteChildWorkflow(workflow.WithChildOptions(ctx, wOptions), "example.v1.HelloWorld.SayMultipleHello", req)
}

// ExecuteChildSayMultipleHelloSync executes the workflow as a child workflow and returns the result when finished
func (c *HelloWorldClient) ExecuteChildSayMultipleHelloSync(ctx workflow.Context, req *MultipleHelloRequest, options ...workflow.ChildWorkflowOptions) (*MultipleHelloResponse, error) {
	future := c.ExecuteChildSayMultipleHello(ctx, req, options...)
	var resp *MultipleHelloResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// HelloWorldSayMultipleHello is a struct that wraps a workflow
type HelloWorldSayMultipleHello struct {
	WorkflowID string
	RunID      string
	client     client.Client
}

// GetSayMultipleHello gets an instance of a given workflow
func (c *HelloWorldClient) GetSayMultipleHello(ctx context.Context, workflowId string, runId string) *HelloWorldSayMultipleHello {
	future := c.client.GetWorkflow(ctx, workflowId, runId)
	return &HelloWorldSayMultipleHello{
		WorkflowID: future.GetID(),
		RunID:      future.GetRunID(),
		client:     c.client,
	}
}

// GetSayMultipleHelloFromFuture gets an instance of a given workflow from a future
func (c *HelloWorldClient) GetSayMultipleHelloFromFuture(future client.WorkflowRun) *HelloWorldSayMultipleHello {
	return &HelloWorldSayMultipleHello{
		WorkflowID: future.GetID(),
		RunID:      future.GetRunID(),
		client:     c.client,
	}
}

// Cancel cancels a given workflow
func (c *HelloWorldSayMultipleHello) Cancel(ctx context.Context) error {
	return c.client.CancelWorkflow(ctx, c.WorkflowID, c.RunID)
}

// Returns the workflow ID
func (c *HelloWorldSayMultipleHello) GetID() string {
	return c.WorkflowID
}

// Returns the run ID
func (c *HelloWorldSayMultipleHello) GetRunID() string {
	return c.RunID
}

// Terminates terminates a given workflow
func (c *HelloWorldSayMultipleHello) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, c.WorkflowID, c.RunID, reason, details...)
}

// Get gets the result of a given workflow with its native type
func (c *HelloWorldSayMultipleHello) Result(ctx context.Context) (*MultipleHelloResponse, error) {
	future := c.client.GetWorkflow(ctx, c.WorkflowID, c.RunID)
	var resp *MultipleHelloResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (c *HelloWorldSayMultipleHello) Get(ctx context.Context, valuePtr interface{}) error {
	future := c.client.GetWorkflow(ctx, c.WorkflowID, c.RunID)
	return future.Get(ctx, valuePtr)
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (c *HelloWorldSayMultipleHello) GetWithOptions(ctx context.Context, valuePtr interface{}, options client.WorkflowRunGetOptions) error {
	future := c.client.GetWorkflow(ctx, c.WorkflowID, c.RunID)
	return future.GetWithOptions(ctx, valuePtr, options)
}

// ResultWithOptions gets the result of a given workflow with its native type
func (c *HelloWorldSayMultipleHello) ResultWithOptions(ctx context.Context, options client.WorkflowRunGetOptions) (*MultipleHelloResponse, error) {
	future := c.client.GetWorkflow(ctx, c.WorkflowID, c.RunID)
	var resp *MultipleHelloResponse
	err := future.GetWithOptions(ctx, &resp, options)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteWorkflowSomeOtherWorkflow executes the workflow and returns a future to it
func (c *HelloWorldClient) ExecuteWorkflowSomeOtherWorkflow(ctx context.Context, req *emptypb.Empty, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	if wOptions.ID == "" {
		wOptions.ID = fmt.Sprintf("%s/%s", "example.v1.HelloWorld.SomeOtherWorkflow", uuid.NewString())
	}
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(int32(86400)) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(int32(7200)) * time.Second
	}
	return c.client.ExecuteWorkflow(ctx, wOptions, "example.v1.HelloWorld.SomeOtherWorkflow", req)
}

// ExecuteWorkflowSomeOtherWorkflowSync executes the workflow and returns the result when finished
func (c *HelloWorldClient) ExecuteWorkflowSomeOtherWorkflowSync(ctx context.Context, req *emptypb.Empty, options ...client.StartWorkflowOptions) (*emptypb.Empty, error) {
	future, err := c.ExecuteWorkflowSomeOtherWorkflow(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	var resp *emptypb.Empty
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// GetWorkflowSomeOtherWorkflowResult gets the result of a given workflow
func (c *HelloWorldClient) GetWorkflowSomeOtherWorkflowResult(ctx context.Context, workflowId string, runId string) (*emptypb.Empty, error) {
	future := c.client.GetWorkflow(ctx, workflowId, runId)
	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteChildSomeOtherWorkflow executes the workflow as a child workflow and returns a future to it
func (c *HelloWorldClient) ExecuteChildSomeOtherWorkflow(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ChildWorkflowOptions) workflow.ChildWorkflowFuture {
	wOptions := workflow.ChildWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	if wOptions.WorkflowID == "" {
		wOptions.WorkflowID = fmt.Sprintf("%s/%s", "example.v1.HelloWorld.SomeOtherWorkflow", uuid.NewString())
	}
	if wOptions.WorkflowExecutionTimeout == 0 {
		wOptions.WorkflowExecutionTimeout = time.Duration(int32(86400)) * time.Second
	}
	if wOptions.WorkflowRunTimeout == 0 {
		wOptions.WorkflowRunTimeout = time.Duration(int32(7200)) * time.Second
	}
	return workflow.ExecuteChildWorkflow(workflow.WithChildOptions(ctx, wOptions), "example.v1.HelloWorld.SomeOtherWorkflow", req)
}

// ExecuteChildSomeOtherWorkflowSync executes the workflow as a child workflow and returns the result when finished
func (c *HelloWorldClient) ExecuteChildSomeOtherWorkflowSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ChildWorkflowOptions) (*emptypb.Empty, error) {
	future := c.ExecuteChildSomeOtherWorkflow(ctx, req, options...)
	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// HelloWorldSomeOtherWorkflow is a struct that wraps a workflow
type HelloWorldSomeOtherWorkflow struct {
	WorkflowID string
	RunID      string
	client     client.Client
}

// GetSomeOtherWorkflow gets an instance of a given workflow
func (c *HelloWorldClient) GetSomeOtherWorkflow(ctx context.Context, workflowId string, runId string) *HelloWorldSomeOtherWorkflow {
	future := c.client.GetWorkflow(ctx, workflowId, runId)
	return &HelloWorldSomeOtherWorkflow{
		WorkflowID: future.GetID(),
		RunID:      future.GetRunID(),
		client:     c.client,
	}
}

// GetSomeOtherWorkflowFromFuture gets an instance of a given workflow from a future
func (c *HelloWorldClient) GetSomeOtherWorkflowFromFuture(future client.WorkflowRun) *HelloWorldSomeOtherWorkflow {
	return &HelloWorldSomeOtherWorkflow{
		WorkflowID: future.GetID(),
		RunID:      future.GetRunID(),
		client:     c.client,
	}
}

// Cancel cancels a given workflow
func (c *HelloWorldSomeOtherWorkflow) Cancel(ctx context.Context) error {
	return c.client.CancelWorkflow(ctx, c.WorkflowID, c.RunID)
}

// Returns the workflow ID
func (c *HelloWorldSomeOtherWorkflow) GetID() string {
	return c.WorkflowID
}

// Returns the run ID
func (c *HelloWorldSomeOtherWorkflow) GetRunID() string {
	return c.RunID
}

// Terminates terminates a given workflow
func (c *HelloWorldSomeOtherWorkflow) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, c.WorkflowID, c.RunID, reason, details...)
}

// Get gets the result of a given workflow with its native type
func (c *HelloWorldSomeOtherWorkflow) Result(ctx context.Context) (*emptypb.Empty, error) {
	future := c.client.GetWorkflow(ctx, c.WorkflowID, c.RunID)
	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (c *HelloWorldSomeOtherWorkflow) Get(ctx context.Context, valuePtr interface{}) error {
	future := c.client.GetWorkflow(ctx, c.WorkflowID, c.RunID)
	return future.Get(ctx, valuePtr)
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (c *HelloWorldSomeOtherWorkflow) GetWithOptions(ctx context.Context, valuePtr interface{}, options client.WorkflowRunGetOptions) error {
	future := c.client.GetWorkflow(ctx, c.WorkflowID, c.RunID)
	return future.GetWithOptions(ctx, valuePtr, options)
}

// ResultWithOptions gets the result of a given workflow with its native type
func (c *HelloWorldSomeOtherWorkflow) ResultWithOptions(ctx context.Context, options client.WorkflowRunGetOptions) (*emptypb.Empty, error) {
	future := c.client.GetWorkflow(ctx, c.WorkflowID, c.RunID)
	var resp *emptypb.Empty
	err := future.GetWithOptions(ctx, &resp, options)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// SendSignalContinue sends the Continue signal to a workflow
func (c *HelloWorldClient) SendSignalContinue(ctx context.Context, workflowID string, runID string, req *ContinueSignalRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, "example.v1.HelloWorld.Continue", req)
}

// ReceiveSignalContinue waits for the the Continue signal
func ReceiveSignalContinue(ctx workflow.Context) (*ContinueSignalRequest, bool) {
	var result *ContinueSignalRequest
	ok := workflow.GetSignalChannel(ctx, "example.v1.HelloWorld.Continue").Receive(ctx, &result)
	return result, ok
}

// ReceiveSignalContinueAsync recieves the the Continue signal asynchronously. It doesn't wait if there is no signal in the queue
func ReceiveSignalContinueAsync(ctx workflow.Context) (*ContinueSignalRequest, bool) {
	var result *ContinueSignalRequest
	ok := workflow.GetSignalChannel(ctx, "example.v1.HelloWorld.Continue").ReceiveAsync(&result)
	return result, ok
}

// QueryGetStatus sends the GetStatus query to a workflow
func (c *HelloWorldClient) QueryGetStatus(ctx context.Context, workflowID string, runID string, req *GetStatusRequest) (*GetStatusResponse, error) {
	future, err := c.client.QueryWorkflow(ctx, workflowID, runID, "example.v1.HelloWorld.GetStatus", req)
	if err != nil {
		return nil, err
	}
	var resp *GetStatusResponse
	err = future.Get(&resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// HandleQueryGetStatus sets up the GetStatus query and responds accordingly, returns an error if it failed
func HandleQueryGetStatus(ctx workflow.Context, queryFunc func(req *GetStatusRequest) (*GetStatusResponse, error)) error {
	return workflow.SetQueryHandler(ctx, "example.v1.HelloWorld.GetStatus", queryFunc)
}
