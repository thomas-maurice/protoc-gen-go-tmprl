// Code generated by protoc-gen-go-tmprl. DO NOT EDIT.
//
// version:
//   protoc-gen-go-tmprl version: master
//   protoc-gen-go-tmprl commit: master
// source file: example/v1/example.proto

package examplev1

import (
	context "context"
	fmt "fmt"
	uuid "github.com/google/uuid"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	time "time"
)

const ( // Default task queue name for the service
	DefaultDieRollTaskQueueName = "service-task-queue"

	// Workflows names constants

	// Name of workflow example.v1.DieRoll.ThrowDies
	WorkflowDieRollThrowDiesName = "example.v1.DieRoll.ThrowDies"
	// Name of workflow example.v1.DieRoll.ThrowUntilValue
	WorkflowDieRollThrowUntilValueName = "example.v1.DieRoll.ThrowUntilValue"

	// Activities names constants

	// Name of activity example.v1.DieRoll.ThrowDie
	ActivityDieRollThrowDieName = "example.v1.DieRoll.ThrowDie"
	// Name of activity example.v1.DieRoll.Ping
	ActivityDieRollPingName = "ping.Ping"

	// Signals names constants

	// Name of signal example.v1.DieRoll.Continue
	SignalDieRollContinueName = "example.v1.DieRoll.Continue"

	// Queries names constants

	// Name of query example.v1.DieRoll.GetThrowsStatus
	QueryDieRollGetThrowsStatusName = "example.v1.DieRoll.GetThrowsStatus"

	// Default timeout for activities when none is specified
	DefaultDieRollScheduleToCloseTimeout = time.Hour
	// Default timeout for activities when none is specified
	DefaultDieRollStartToCloseTimeout = time.Hour
)

// DieRollService is the interface your service must implement
//
// Service hello world is an example implementation of a service

type DieRollService interface {
	// Workflows definitions

	// Throws dies a few times and return the result
	ThrowDies(ctx workflow.Context, req *ThrowDiesRequest) (*ThrowDiesResponse, error)
	//
	ThrowUntilValue(ctx workflow.Context, req *ThrowUntilValueRequest) (*emptypb.Empty, error)

	// Activities definitions

	// Throws a d6 and returns the result
	ThrowDie(ctx context.Context, req *emptypb.Empty) (*ThrowDieResponse, error)
	// Just a simple ping
	// Takes no parameters
	// returns nothing
	Ping(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error)
}

// DieRollWorker: Worker for the DieRoll service
type DieRollWorker struct {
	client client.Client
	worker worker.Worker
	svc    DieRollService
}

// NewDieRollWorker: Returns a new instance of the worker.
// If `taskQueue` stays empty the default one will be used
func NewDieRollWorker(client client.Client, svc DieRollService, taskQueue string, workerOptions ...worker.Options) (*DieRollWorker, error) {
	wOpts := worker.Options{}
	if taskQueue == "" {
		taskQueue = DefaultDieRollTaskQueueName
	}
	if len(workerOptions) > 0 {
		wOpts = workerOptions[0]
	}
	w := worker.New(client, taskQueue, wOpts)
	return &DieRollWorker{
		client: client,
		svc:    svc,
		worker: w,
	}, nil
}

// Register registers the worker and its activities/workflows in temporal
func (w *DieRollWorker) Register() {
	// Registers activity ThrowDie
	w.worker.RegisterActivityWithOptions(w.svc.ThrowDie, activity.RegisterOptions{
		Name: "example.v1.DieRoll.ThrowDie",
	})
	// Registers activity Ping
	w.worker.RegisterActivityWithOptions(w.svc.Ping, activity.RegisterOptions{
		Name: "ping.Ping",
	})
	// Registers workflow ThrowDies
	w.worker.RegisterWorkflowWithOptions(w.svc.ThrowDies, workflow.RegisterOptions{
		Name: "example.v1.DieRoll.ThrowDies",
	})
	// Registers workflow ThrowUntilValue
	w.worker.RegisterWorkflowWithOptions(w.svc.ThrowUntilValue, workflow.RegisterOptions{
		Name: "example.v1.DieRoll.ThrowUntilValue",
	})
}

// Run will run the worker
func (w *DieRollWorker) Run() error {
	return w.worker.Run(worker.InterruptCh())
}

// Stop will stop the worker, may panic if called twice
func (w *DieRollWorker) Stop() {
	w.worker.Stop()
}

// DieRollClient: Client for the DieRoll service
type DieRollClient struct {
	client    client.Client
	taskQueue string
}

// NewDieRollClient: Returns a new instance of the client.
// If `taskQueue` stays empty the default one will be used
func NewDieRollClient(client client.Client, taskQueue ...string) (*DieRollClient, error) {
	clientTaskQueue := DefaultDieRollTaskQueueName
	if len(taskQueue) > 0 {
		clientTaskQueue = taskQueue[0]
	}
	return &DieRollClient{
		client:    client,
		taskQueue: clientTaskQueue,
	}, nil
}

// ExecuteActivityThrowDie executes the activity asynchronously and returns a future to it
func (c *DieRollClient) ExecuteActivityThrowDie(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) workflow.Future {
	var aOptions workflow.ActivityOptions
	if len(options) > 0 {
		aOptions = options[0]
	}
	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if aOptions.ActivityID == "" {
		aOptions.ActivityID = fmt.Sprintf("%s/%s", "example.v1.DieRoll.ThrowDie", uuid.NewString())
	}
	if aOptions.ScheduleToCloseTimeout == 0 {
		aOptions.ScheduleToCloseTimeout = DefaultDieRollScheduleToCloseTimeout
	}
	if aOptions.StartToCloseTimeout == 0 {
		aOptions.StartToCloseTimeout = DefaultDieRollStartToCloseTimeout
	}
	if aOptions.StartToCloseTimeout == 0 {
		aOptions.StartToCloseTimeout = time.Duration(int32(120)) * time.Second
	}
	if aOptions.ScheduleToCloseTimeout == 0 {
		aOptions.ScheduleToCloseTimeout = time.Duration(int32(120)) * time.Second
	}
	if aOptions.ScheduleToStartTimeout == 0 {
		aOptions.ScheduleToStartTimeout = time.Duration(int32(30)) * time.Second
	}
	if aOptions.RetryPolicy == nil {
		aOptions.RetryPolicy = &temporal.RetryPolicy{
			InitialInterval:    time.Duration(int32(1)) * time.Second,
			MaximumInterval:    time.Duration(int32(10)) * time.Second,
			BackoffCoefficient: float64(float32(1.5)),
			MaximumAttempts:    int32(10),
			NonRetryableErrorTypes: []string{
				"FATAL",
			},
		}
	}
	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aOptions), "example.v1.DieRoll.ThrowDie", req)
}

// ExecuteActivityThrowDieSync executes the activity synchronously and returns the result when finished
func (c *DieRollClient) ExecuteActivityThrowDieSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) (*ThrowDieResponse, error) {
	aOptions := workflow.ActivityOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		aOptions = options[0]
	}
	future := c.ExecuteActivityThrowDie(ctx, req, aOptions)
	var resp *ThrowDieResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteActivityPing executes the activity asynchronously and returns a future to it
func (c *DieRollClient) ExecuteActivityPing(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) workflow.Future {
	var aOptions workflow.ActivityOptions
	if len(options) > 0 {
		aOptions = options[0]
	}
	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if aOptions.ActivityID == "" {
		aOptions.ActivityID = fmt.Sprintf("%s/%s", "ping.Ping", uuid.NewString())
	}
	if aOptions.ScheduleToCloseTimeout == 0 {
		aOptions.ScheduleToCloseTimeout = DefaultDieRollScheduleToCloseTimeout
	}
	if aOptions.StartToCloseTimeout == 0 {
		aOptions.StartToCloseTimeout = DefaultDieRollStartToCloseTimeout
	}
	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aOptions), "ping.Ping", req)
}

// ExecuteActivityPingSync executes the activity synchronously and returns the result when finished
func (c *DieRollClient) ExecuteActivityPingSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) (*emptypb.Empty, error) {
	aOptions := workflow.ActivityOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		aOptions = options[0]
	}
	future := c.ExecuteActivityPing(ctx, req, aOptions)
	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteWorkflowThrowDies executes the workflow and returns a future to it
func (c *DieRollClient) ExecuteWorkflowThrowDies(ctx context.Context, req *ThrowDiesRequest, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.ID == "" {
		wOptions.ID = fmt.Sprintf("%s/%s", "example.v1.DieRoll.ThrowDies", uuid.NewString())
	}
	return c.client.ExecuteWorkflow(ctx, wOptions, "example.v1.DieRoll.ThrowDies", req)
}

// ExecuteWorkflowThrowDiesSync executes the workflow and returns the result when finished
func (c *DieRollClient) ExecuteWorkflowThrowDiesSync(ctx context.Context, req *ThrowDiesRequest, options ...client.StartWorkflowOptions) (*ThrowDiesResponse, error) {
	future, err := c.ExecuteWorkflowThrowDies(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	var resp *ThrowDiesResponse
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// GetWorkflowThrowDiesResult gets the result of a given workflow
func (c *DieRollClient) GetWorkflowThrowDiesResult(ctx context.Context, workflowId string, runId string) (*ThrowDiesResponse, error) {
	future := c.client.GetWorkflow(ctx, workflowId, runId)
	var resp *ThrowDiesResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteChildThrowDies executes the workflow as a child workflow and returns a future to it
func (c *DieRollClient) ExecuteChildThrowDies(ctx workflow.Context, req *ThrowDiesRequest, options ...workflow.ChildWorkflowOptions) workflow.ChildWorkflowFuture {
	wOptions := workflow.ChildWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.WorkflowID == "" {
		wOptions.WorkflowID = fmt.Sprintf("%s/%s", "example.v1.DieRoll.ThrowDies", uuid.NewString())
	}
	return workflow.ExecuteChildWorkflow(workflow.WithChildOptions(ctx, wOptions), "example.v1.DieRoll.ThrowDies", req)
}

// ExecuteChildThrowDiesSync executes the workflow as a child workflow and returns the result when finished
func (c *DieRollClient) ExecuteChildThrowDiesSync(ctx workflow.Context, req *ThrowDiesRequest, options ...workflow.ChildWorkflowOptions) (*ThrowDiesResponse, error) {
	future := c.ExecuteChildThrowDies(ctx, req, options...)
	var resp *ThrowDiesResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteWorkflowThrowUntilValue executes the workflow and returns a future to it
func (c *DieRollClient) ExecuteWorkflowThrowUntilValue(ctx context.Context, req *ThrowUntilValueRequest, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.ID == "" {
		wOptions.ID = fmt.Sprintf("%s/%s", "example.v1.DieRoll.ThrowUntilValue", uuid.NewString())
	}
	return c.client.ExecuteWorkflow(ctx, wOptions, "example.v1.DieRoll.ThrowUntilValue", req)
}

// ExecuteWorkflowThrowUntilValueSync executes the workflow and returns the result when finished
func (c *DieRollClient) ExecuteWorkflowThrowUntilValueSync(ctx context.Context, req *ThrowUntilValueRequest, options ...client.StartWorkflowOptions) (*emptypb.Empty, error) {
	future, err := c.ExecuteWorkflowThrowUntilValue(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	var resp *emptypb.Empty
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// GetWorkflowThrowUntilValueResult gets the result of a given workflow
func (c *DieRollClient) GetWorkflowThrowUntilValueResult(ctx context.Context, workflowId string, runId string) (*emptypb.Empty, error) {
	future := c.client.GetWorkflow(ctx, workflowId, runId)
	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteChildThrowUntilValue executes the workflow as a child workflow and returns a future to it
func (c *DieRollClient) ExecuteChildThrowUntilValue(ctx workflow.Context, req *ThrowUntilValueRequest, options ...workflow.ChildWorkflowOptions) workflow.ChildWorkflowFuture {
	wOptions := workflow.ChildWorkflowOptions{
		TaskQueue: c.taskQueue,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultDieRollTaskQueueName
	}
	if wOptions.WorkflowID == "" {
		wOptions.WorkflowID = fmt.Sprintf("%s/%s", "example.v1.DieRoll.ThrowUntilValue", uuid.NewString())
	}
	return workflow.ExecuteChildWorkflow(workflow.WithChildOptions(ctx, wOptions), "example.v1.DieRoll.ThrowUntilValue", req)
}

// ExecuteChildThrowUntilValueSync executes the workflow as a child workflow and returns the result when finished
func (c *DieRollClient) ExecuteChildThrowUntilValueSync(ctx workflow.Context, req *ThrowUntilValueRequest, options ...workflow.ChildWorkflowOptions) (*emptypb.Empty, error) {
	future := c.ExecuteChildThrowUntilValue(ctx, req, options...)
	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// DieRollThrowDies is a struct that wraps a workflow
type DieRollThrowDies struct {
	client     client.Client
	future     client.WorkflowRun
	workflowId string
	runId      string
}

// GetThrowDies gets an instance of a given workflow
func (c *DieRollClient) GetThrowDies(ctx context.Context, workflowId string, runId string) *DieRollThrowDies {
	future := c.client.GetWorkflow(ctx, workflowId, runId)
	return &DieRollThrowDies{
		client:     c.client,
		future:     future,
		workflowId: workflowId,
		runId:      runId,
	}
}

// GetThrowDiesFromRun gets an instance of a given workflow from a future
func (c *DieRollClient) GetThrowDiesFromRun(future client.WorkflowRun) *DieRollThrowDies {
	return &DieRollThrowDies{
		workflowId: future.GetID(),
		runId:      future.GetRunID(),
		client:     c.client,
		future:     future,
	}
}

// Cancel cancels a given workflow
func (w *DieRollThrowDies) Cancel(ctx context.Context) error {
	return w.client.CancelWorkflow(ctx, w.workflowId, w.runId)
}

// Returns the workflow ID
func (w *DieRollThrowDies) GetID() string {
	return w.future.GetID()
}

// Returns the run ID
func (w *DieRollThrowDies) GetRunID() string {
	return w.future.GetRunID()
}

// Terminates terminates a given workflow
func (w *DieRollThrowDies) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return w.client.TerminateWorkflow(ctx, w.workflowId, w.runId, reason, details...)
}

// Get gets the result of a given workflow with its native type
func (w *DieRollThrowDies) Result(ctx context.Context) (*ThrowDiesResponse, error) {
	var resp *ThrowDiesResponse
	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ResultWithOptions gets the result of a given workflow with its native type
func (w *DieRollThrowDies) ResultWithOptions(ctx context.Context, options client.WorkflowRunGetOptions) (*ThrowDiesResponse, error) {
	var resp *ThrowDiesResponse
	err := w.future.GetWithOptions(ctx, &resp, options)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollThrowDies) Get(ctx context.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollThrowDies) GetWithOptions(ctx context.Context, valuePtr interface{}, options client.WorkflowRunGetOptions) error {
	return w.future.GetWithOptions(ctx, valuePtr, options)
}

// SignalContinue sends the Continue signal to the workflow
func (w *DieRollThrowDies) SignalContinue(ctx context.Context, req *ContinueSignalRequest) error {
	return w.client.SignalWorkflow(ctx, w.future.GetID(), w.future.GetRunID(), "example.v1.DieRoll.Continue", req)
}

// ChildDieRollThrowDiesExecution is a struct that wraps a workflow execution (called from another workflow)
type ChildDieRollThrowDiesExecution struct {
	client client.Client
	future workflow.ChildWorkflowFuture
}

// GetChildDieRollThrowDiesExecution gets an instance of a given workflow from a future
func (c *DieRollClient) GetChildDieRollThrowDiesExecution(future workflow.ChildWorkflowFuture) *ChildDieRollThrowDiesExecution {
	return &ChildDieRollThrowDiesExecution{
		client: c.client,
		future: future,
	}
}

// Get gets the result of a given workflow with its native type
func (w *ChildDieRollThrowDiesExecution) Result(ctx workflow.Context) (*ThrowDiesResponse, error) {
	var resp *ThrowDiesResponse
	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollThrowDiesExecution) Get(ctx workflow.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// Wraps the GetChildWorkflowExecution and returns an workflow.Future
func (w *ChildDieRollThrowDiesExecution) GetChildWorkflowExecution() (ctx workflow.Future) {
	return w.future
}

// Wraps the IsReady method from the future
func (w *ChildDieRollThrowDiesExecution) IsReady() bool {
	return w.future.IsReady()
}

// Signals the child workflow with a generic signal -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollThrowDiesExecution) SignalChildWorkflow(ctx workflow.Context, sigName string, data interface{}) workflow.Future {
	return w.future.SignalChildWorkflow(ctx, sigName, data)
}

// SignalContinue sends the Continue signal to the workflow
func (w *ChildDieRollThrowDiesExecution) SignalContinue(ctx workflow.Context, req *ContinueSignalRequest) error {
	return w.future.SignalChildWorkflow(ctx, "example.v1.DieRoll.Continue", req).Get(ctx, nil)
}

// DieRollThrowUntilValue is a struct that wraps a workflow
type DieRollThrowUntilValue struct {
	client     client.Client
	future     client.WorkflowRun
	workflowId string
	runId      string
}

// GetThrowUntilValue gets an instance of a given workflow
func (c *DieRollClient) GetThrowUntilValue(ctx context.Context, workflowId string, runId string) *DieRollThrowUntilValue {
	future := c.client.GetWorkflow(ctx, workflowId, runId)
	return &DieRollThrowUntilValue{
		client:     c.client,
		future:     future,
		workflowId: workflowId,
		runId:      runId,
	}
}

// GetThrowUntilValueFromRun gets an instance of a given workflow from a future
func (c *DieRollClient) GetThrowUntilValueFromRun(future client.WorkflowRun) *DieRollThrowUntilValue {
	return &DieRollThrowUntilValue{
		workflowId: future.GetID(),
		runId:      future.GetRunID(),
		client:     c.client,
		future:     future,
	}
}

// Cancel cancels a given workflow
func (w *DieRollThrowUntilValue) Cancel(ctx context.Context) error {
	return w.client.CancelWorkflow(ctx, w.workflowId, w.runId)
}

// Returns the workflow ID
func (w *DieRollThrowUntilValue) GetID() string {
	return w.future.GetID()
}

// Returns the run ID
func (w *DieRollThrowUntilValue) GetRunID() string {
	return w.future.GetRunID()
}

// Terminates terminates a given workflow
func (w *DieRollThrowUntilValue) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return w.client.TerminateWorkflow(ctx, w.workflowId, w.runId, reason, details...)
}

// Get gets the result of a given workflow with its native type
func (w *DieRollThrowUntilValue) Result(ctx context.Context) (*emptypb.Empty, error) {
	var resp *emptypb.Empty
	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ResultWithOptions gets the result of a given workflow with its native type
func (w *DieRollThrowUntilValue) ResultWithOptions(ctx context.Context, options client.WorkflowRunGetOptions) (*emptypb.Empty, error) {
	var resp *emptypb.Empty
	err := w.future.GetWithOptions(ctx, &resp, options)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollThrowUntilValue) Get(ctx context.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.WorkflowRun
func (w *DieRollThrowUntilValue) GetWithOptions(ctx context.Context, valuePtr interface{}, options client.WorkflowRunGetOptions) error {
	return w.future.GetWithOptions(ctx, valuePtr, options)
}

// QueryGetThrowsStatus queries the workflow with GetThrowsStatus
func (w *DieRollThrowUntilValue) QueryGetThrowsStatus(ctx context.Context, req *emptypb.Empty) (*ThrowStatusResponse, error) {
	future, err := w.client.QueryWorkflow(ctx, w.future.GetID(), w.future.GetRunID(), "example.v1.DieRoll.GetThrowsStatus", req)
	if err != nil {
		return nil, err
	}
	var resp *ThrowStatusResponse
	err = future.Get(&resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ChildDieRollThrowUntilValueExecution is a struct that wraps a workflow execution (called from another workflow)
type ChildDieRollThrowUntilValueExecution struct {
	client client.Client
	future workflow.ChildWorkflowFuture
}

// GetChildDieRollThrowUntilValueExecution gets an instance of a given workflow from a future
func (c *DieRollClient) GetChildDieRollThrowUntilValueExecution(future workflow.ChildWorkflowFuture) *ChildDieRollThrowUntilValueExecution {
	return &ChildDieRollThrowUntilValueExecution{
		client: c.client,
		future: future,
	}
}

// Get gets the result of a given workflow with its native type
func (w *ChildDieRollThrowUntilValueExecution) Result(ctx workflow.Context) (*emptypb.Empty, error) {
	var resp *emptypb.Empty
	err := w.future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// Get gets the result of a given workflow with pointers -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollThrowUntilValueExecution) Get(ctx workflow.Context, valuePtr interface{}) error {
	return w.future.Get(ctx, valuePtr)
}

// Wraps the GetChildWorkflowExecution and returns an workflow.Future
func (w *ChildDieRollThrowUntilValueExecution) GetChildWorkflowExecution() (ctx workflow.Future) {
	return w.future
}

// Wraps the IsReady method from the future
func (w *ChildDieRollThrowUntilValueExecution) IsReady() bool {
	return w.future.IsReady()
}

// Signals the child workflow with a generic signal -- discouraged to use but required to implement internal.Future
func (w *ChildDieRollThrowUntilValueExecution) SignalChildWorkflow(ctx workflow.Context, sigName string, data interface{}) workflow.Future {
	return w.future.SignalChildWorkflow(ctx, sigName, data)
}

// SendSignalContinue sends the Continue signal to a workflow
func (c *DieRollClient) SendSignalContinue(ctx context.Context, workflowID string, runID string, req *ContinueSignalRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, "example.v1.DieRoll.Continue", req)
}

// ReceiveSignalContinue waits for the the Continue signal
func ReceiveSignalContinue(ctx workflow.Context) (*ContinueSignalRequest, bool) {
	var result *ContinueSignalRequest
	ok := workflow.GetSignalChannel(ctx, "example.v1.DieRoll.Continue").Receive(ctx, &result)
	return result, ok
}

// ReceiveSignalContinueAsync recieves the the Continue signal asynchronously. It doesn't wait if there is no signal in the queue
func ReceiveSignalContinueAsync(ctx workflow.Context) (*ContinueSignalRequest, bool) {
	var result *ContinueSignalRequest
	ok := workflow.GetSignalChannel(ctx, "example.v1.DieRoll.Continue").ReceiveAsync(&result)
	return result, ok
}

// QueryGetThrowsStatus sends the GetThrowsStatus query to a workflow
func (c *DieRollClient) QueryGetThrowsStatus(ctx context.Context, workflowID string, runID string, req *emptypb.Empty) (*ThrowStatusResponse, error) {
	future, err := c.client.QueryWorkflow(ctx, workflowID, runID, "example.v1.DieRoll.GetThrowsStatus", req)
	if err != nil {
		return nil, err
	}
	var resp *ThrowStatusResponse
	err = future.Get(&resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// HandleQueryGetThrowsStatus sets up the GetThrowsStatus query and responds accordingly, returns an error if it failed
func HandleQueryGetThrowsStatus(ctx workflow.Context, queryFunc func(req *emptypb.Empty) (*ThrowStatusResponse, error)) error {
	return workflow.SetQueryHandler(ctx, "example.v1.DieRoll.GetThrowsStatus", queryFunc)
}
