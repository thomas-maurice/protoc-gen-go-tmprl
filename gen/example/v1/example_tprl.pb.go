// Code generated by protoc-gen-go-tmprl. DO NOT EDIT.

package examplev1

import (
	context "context"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

const (
	DefaultHelloWorldTaskQueueName = "hello-task-queue"
	// Workflows names constants

	// Name of workflow example.v1.HelloWorld.SayMultipleHello
	WorkflowHelloWorldSayMultipleHelloName = "example.v1.HelloWorld.SayMultipleHello"
	// Activities names constants

	// Name of activity example.v1.HelloWorld.SayHello
	ActivityHelloWorldSayHelloName = "hello.SayHello"
	// Name of activity example.v1.HelloWorld.Ping
	ActivityHelloWorldPingName = "example.v1.HelloWorld.Ping"
)

// HelloWorldService is the interface your service must implement
//
// Service hello world is an example implementation of a service
type HelloWorldService interface {
	// Workflows definitions

	// Say hello to multiple people
	SayMultipleHello(ctx workflow.Context, req *MultipleHelloRequest) (*MultipleHelloResponse, error)

	// Activities definitions

	// Says hello and returns a string
	SayHello(ctx context.Context, req *HelloRequest) (*HelloResponse, error)
	// Just a simple ping
	// Takes no parameters
	// returns nothing
	Ping(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error)
}

// HelloWorldWorker: Worker for the HelloWorld service
type HelloWorldWorker struct {
	client client.Client
	worker worker.Worker
	svc    HelloWorldService
}

// NewHelloWorldWorker: Returns a new instance of the worker.
// If `taskQueue` stays empty the default one will be used
func NewHelloWorldWorker(client client.Client, svc HelloWorldService, taskQueue string, workerOptions ...worker.Options) (*HelloWorldWorker, error) {
	wOpts := worker.Options{}
	if taskQueue == "" {
		taskQueue = DefaultHelloWorldTaskQueueName
	}
	if len(workerOptions) > 0 {
		wOpts = workerOptions[0]
	}
	w := worker.New(client, taskQueue, wOpts)
	return &HelloWorldWorker{
		client: client,
		svc:    svc,
		worker: w,
	}, nil
}

// Register registers the worker and its activities/workflows in temporal
func (w *HelloWorldWorker) Register() {
	// Registers activity SayHello
	w.worker.RegisterActivityWithOptions(w.svc.SayHello, activity.RegisterOptions{
		Name: "hello.SayHello",
	})
	// Registers activity Ping
	w.worker.RegisterActivityWithOptions(w.svc.Ping, activity.RegisterOptions{
		Name: "example.v1.HelloWorld.Ping",
	})
	// Registers workflow SayMultipleHello
	w.worker.RegisterWorkflowWithOptions(w.svc.SayMultipleHello, workflow.RegisterOptions{
		Name: "example.v1.HelloWorld.SayMultipleHello",
	})
}

// Run will run the worker
func (w *HelloWorldWorker) Run() error {
	return w.worker.Run(worker.InterruptCh())
}

// Stop will stop the worker, may panic if called twice
func (w *HelloWorldWorker) Stop() {
	w.worker.Stop()
}

// HelloWorldClient: Client for the HelloWorld service
type HelloWorldClient struct {
	client    client.Client
	taskQueue string
}

// NewHelloWorldClient: Returns a new instance of the client.
// If `taskQueue` stays empty the default one will be used
func NewHelloWorldClient(client client.Client, taskQueue ...string) (*HelloWorldClient, error) {
	clientTaskQueue := DefaultHelloWorldTaskQueueName
	if len(taskQueue) > 0 {
		clientTaskQueue = taskQueue[0]
	}
	return &HelloWorldClient{
		client:    client,
		taskQueue: clientTaskQueue,
	}, nil
}

// ExecuteActivitySayHello executes the activity asynchronously and returns a future to it
func (c *HelloWorldClient) ExecuteActivitySayHello(ctx workflow.Context, req *HelloRequest, options ...workflow.ActivityOptions) workflow.Future {
	var aOptions workflow.ActivityOptions
	if len(options) > 0 {
		aOptions = options[0]
	}
	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aOptions), "hello.SayHello", req)
}

// ExecuteActivitySayHelloSync executes the activity synchronously and returns the result when finished
func (c *HelloWorldClient) ExecuteActivitySayHelloSync(ctx workflow.Context, req *HelloRequest, options ...workflow.ActivityOptions) (*HelloResponse, error) {
	aOptions := workflow.ActivityOptions{
		TaskQueue: DefaultHelloWorldTaskQueueName,
	}
	if len(options) > 0 {
		aOptions = options[0]
	}
	future := c.ExecuteActivitySayHello(ctx, req, aOptions)
	var resp *HelloResponse
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteActivityPing executes the activity asynchronously and returns a future to it
func (c *HelloWorldClient) ExecuteActivityPing(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) workflow.Future {
	var aOptions workflow.ActivityOptions
	if len(options) > 0 {
		aOptions = options[0]
	}
	if aOptions.TaskQueue == "" {
		aOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	return workflow.ExecuteActivity(workflow.WithActivityOptions(ctx, aOptions), "example.v1.HelloWorld.Ping", req)
}

// ExecuteActivityPingSync executes the activity synchronously and returns the result when finished
func (c *HelloWorldClient) ExecuteActivityPingSync(ctx workflow.Context, req *emptypb.Empty, options ...workflow.ActivityOptions) (*emptypb.Empty, error) {
	aOptions := workflow.ActivityOptions{
		TaskQueue: DefaultHelloWorldTaskQueueName,
	}
	if len(options) > 0 {
		aOptions = options[0]
	}
	future := c.ExecuteActivityPing(ctx, req, aOptions)
	var resp *emptypb.Empty
	err := future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteWorkflowSayMultipleHello executes the workflow and returns a future to it
func (c *HelloWorldClient) ExecuteWorkflowSayMultipleHello(ctx context.Context, req *MultipleHelloRequest, options ...client.StartWorkflowOptions) (client.WorkflowRun, error) {
	wOptions := client.StartWorkflowOptions{
		TaskQueue: DefaultHelloWorldTaskQueueName,
	}
	if len(options) > 0 {
		wOptions = options[0]
	}
	if wOptions.TaskQueue == "" {
		wOptions.TaskQueue = DefaultHelloWorldTaskQueueName
	}
	return c.client.ExecuteWorkflow(ctx, wOptions, "example.v1.HelloWorld.SayMultipleHello", req)
}

// ExecuteWorkflowSayMultipleHelloSync executes the workflow and returns the result when finished
func (c *HelloWorldClient) ExecuteWorkflowSayMultipleHelloSync(ctx context.Context, req *MultipleHelloRequest, options ...client.StartWorkflowOptions) (*MultipleHelloResponse, error) {
	future, err := c.ExecuteWorkflowSayMultipleHello(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	var resp *MultipleHelloResponse
	err = future.Get(ctx, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

// ExecuteChildSayMultipleHello executes the workflow as a child workflow and returns a future to it
// ExecuteChildSayMultipleHelloSync executes the workflow as a child workflow and returns the result when finished
